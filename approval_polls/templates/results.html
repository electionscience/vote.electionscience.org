{% extends 'base.html' %}
{% load filters %}
{% block content %}
    <div class="container">
        <h1 class="mb-4">{{ poll.question }}</h1>
        <div class="mb-4">
            <h2 class="h4 text-muted">
                {{ poll.total_ballots }} ballot{{ poll.total_ballots|pluralize }}
                {% if poll.is_closed and poll.total_votes == 0 %}<small class="d-block mt-2">No votes in this poll</small>{% endif %}
            </h2>
        </div>
        <!-- Approval Voting Results Section -->
        <div class="mb-4">
            {% for choice in choices %}
                <div class="mb-4 {% if choice in leading_choices %}border border-success rounded p-3{% endif %}">
                    <h3 class="h5 {% if choice in leading_choices %}text-success font-weight-bold{% endif %}">
                        {{ choice.choice_text }}
                        {% if choice in leading_choices %}
                            <span class="badge bg-success ms-2">
                                {% if poll.is_closed %}
                                    Winner
                                {% else %}
                                    Leading
                                {% endif %}
                                <i class="bi bi-trophy-fill ms-1"></i>
                            </span>
                        {% endif %}
                    </h3>
                    <p class="text-muted">
                        {{ choice.vote_count }} vote{{ choice.vote_count|pluralize }}
                        ({{ choice.percentage|to_percent_str }})
                        {% if choice in leading_choices %}
                            <span class="text-success font-weight-bold"><i class="bi bi-arrow-up-circle-fill"></i></span>
                        {% endif %}
                    </p>
                    <div class="progress" style="height: 25px;">
                        <div class="progress-bar {% if choice in leading_choices %}bg-success{% endif %}"
                             role="progressbar"
                             style="width: {% widthratio choice.vote_count poll.total_ballots 100 %}%"
                             aria-valuenow="{% widthratio choice.vote_count poll.total_ballots 100 %}"
                             aria-valuemin="0"
                             aria-valuemax="{{ poll.total_ballots }}">
                            <span class="font-weight-bold">{% widthratio choice.vote_count poll.total_ballots 100 %}%</span>
                        </div>
                    </div>
                </div>
            {% endfor %}
        </div>
        <!-- Proportional Voting Results Section -->
        <div class="mt-5">
            <div class="accordion" id="proportionalResultsAccordion">
                <div class="accordion-item">
                    <h2 class="accordion-header" id="headingProportional">
                        <button class="accordion-button collapsed"
                                type="button"
                                data-bs-toggle="collapse"
                                data-bs-target="#collapseProportional"
                                aria-expanded="false"
                                aria-controls="collapseProportional">View Proportional Voting Results</button>
                    </h2>
                    <div id="collapseProportional"
                         class="accordion-collapse collapse"
                         aria-labelledby="headingProportional"
                         data-bs-parent="#proportionalResultsAccordion">
                        <div class="accordion-body">
                            <p>
                                When electing multiple candidates to a board or committee <a href="https://en.wikipedia.org/wiki/Sequential_proportional_approval_voting">Proportional Approval Voting</a>
                                ensures that no single voting group dominates the outcome, promoting fair representation and reflecting the diverse preferences of all voters. In scenarios where there are more seats than choices available and where each choice represents a party—this method can allow a popular party to be allocated multiple seats proportionally, mirroring the party’s share of overall support.
                            </p>
                            <!-- Slider to pick the number of seats -->
                            <label for="seatsSlider" class="form-label mt-3">
                                Number of seats: <span id="seatsValue">5</span>
                            </label>
                            <input type="range"
                                   class="form-range"
                                   min="1"
                                   max="100"
                                   value="5"
                                   id="seatsSlider" />
                            <!-- Chart.js Pie Chart -->
                            <canvas id="spavChart"
                                    class="my-4"
                                    style="max-width: 600px;
                                           height: 400px;
                                           margin: 20px auto"></canvas>
                            <!-- Dynamic winners list -->
                            <div id="winnersList"></div>
                            <!-- SPAV Debug Log -->
                            <h3 class="mt-4">Allocation Steps</h3>
                            <div id="allocationLog"
                                 style="white-space: pre;
                                        background: #f8f9fa;
                                        border: 1px solid #ddd;
                                        padding: 1rem;
                                        max-height: 300px;
                                        overflow:auto">
                                <!-- The SPAV debug log text will appear here -->
                            </div>
                            <!-- Votes Table for debugging (optional) -->
                            <h3 class="mt-5">Cast Vote Record</h3>
                            <div id="votesTable"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<!-- Load Chart.js -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
    document.addEventListener('DOMContentLoaded', async function () {
      const pollId = '{{ poll.id }}'
      const seatsSlider = document.getElementById('seatsSlider')
      const seatsValue = document.getElementById('seatsValue')
      const winnersList = document.getElementById('winnersList')
      const votesTableDiv = document.getElementById('votesTable')
      const allocationLogDiv = document.getElementById('allocationLog')

      let rawBallots = []
      let choices = []

      // 1. Fetch raw ballots + choices from /raw endpoint once
      try {
        const response = await fetch(`/polls/${pollId}/raw`)
        const data = await response.json()
        rawBallots = data.ballots // e.g. [[1,2], [2,3], ...]
        choices = data.choices // e.g. [{ id:1, choice_text:'Party A'}, ...]
      } catch (error) {
        console.error('Error fetching raw data:', error)
        return
      }

      // Build a debug table of ballots (optional)
      buildVotesTable(rawBallots, choices)

      // 2. Create Chart.js pie chart
      const ctx = document.getElementById('spavChart').getContext('2d')
      const spavChart = new Chart(ctx, {
        type: 'pie',
        data: {
          labels: choices.map((c) => c.choice_text),
          datasets: [
            {
              data: choices.map(() => 0),
              backgroundColor: ['rgba(75, 192, 192, 0.6)', 'rgba(255, 99, 132, 0.6)', 'rgba(255, 206, 86, 0.6)', 'rgba(54, 162, 235, 0.6)', 'rgba(153, 102, 255, 0.6)', 'rgba(255, 159, 64, 0.6)'],
              borderColor: ['rgba(75, 192, 192, 1)', 'rgba(255, 99, 132, 1)', 'rgba(255, 206, 86, 1)', 'rgba(54, 162, 235, 1)', 'rgba(153, 102, 255, 1)', 'rgba(255, 159, 64, 1)'],
              borderWidth: 1
            }
          ]
        },
        options: {
          responsive: false,
          plugins: {
            legend: {
              position: 'bottom'
            }
          }
        }
      })


      // 3. SPAV allowing multiple seats, now with a debug log
      function spav(choices, ballots, seats) {
        const debugLines = []

        // Each choice gets a seatCount property
        const results = choices.map((c) => ({
          id: c.id,
          text: c.choice_text,
          seatCount: 0
        }))

        // For each ballot, track how many seats they've contributed to so far
        const ballotWinnerCounts = new Array(ballots.length).fill(0)

        for (let seat = 0; seat < seats; seat++) {
          const seatNumber = seat + 1
          debugLines.push(`\nSEAT #${seatNumber} Calculation:`)

          // 3.1 Calculate total weight for each choice
          const weights = new Map() // choiceId -> sum of ballot weights
          results.forEach((r) => weights.set(r.id, 0))

          ballots.forEach((approvedChoices, bIndex) => {
            // Weighted by 1 / (1 + ballotWinnerCounts[bIndex])
            const ballotWeight = 1 / (1 + ballotWinnerCounts[bIndex])

            approvedChoices.forEach((choiceId) => {
              // This is SPAV, so a choice can keep winning multiple seats
              const prev = weights.get(choiceId) || 0
              weights.set(choiceId, prev + ballotWeight)
            })
          })

          // Log each choice's weight
          for (const r of results) {
            const w = weights.get(r.id).toFixed(3)
            debugLines.push(`  "${r.text}" => sum weighted votes: ${w}`)
          }

          // 3.2 Find the choice with the highest weight
          let bestChoiceId = null
          let bestWeight = -1
          for (const [choiceId, totalWeight] of weights.entries()) {
            if (totalWeight > bestWeight) {
              bestWeight = totalWeight
              bestChoiceId = choiceId
            }
          }

          // 3.3 Allocate seat
          if (bestChoiceId !== null) {
            const winner = results.find((r) => r.id === bestChoiceId)
            winner.seatCount += 1
            debugLines.push(`  ==> Winner for seat #${seatNumber}: "${winner.text}" (ID=${winner.id}) with ${bestWeight.toFixed(3)} votes`)

            // Increase 'winner count' for each ballot that approved the winner
            ballots.forEach((approvedChoices, bIndex) => {
              if (approvedChoices.includes(bestChoiceId)) {
                ballotWinnerCounts[bIndex] += 1
              }
            })
          } else {
            debugLines.push(`  No candidates can win seat #${seatNumber} - stopping early.`)
            break
          }
        }

        return { results, debugLines }
      }

      const spavCache = new Map();

      // 4. Update chart + winners + debug log
      function updateAllocation() {
        const seats = parseInt(seatsSlider.value);
        seatsValue.textContent = seats;

        // 1) Check if we have a cached result
        let cached = spavCache[seats]; // or spavCache.get(seats) if using a Map

        if (!cached) {
          // 2) Not in cache; compute
          const { results, debugLines } = spav(choices, rawBallots, seats);
          // 3) Store it
          cached = { results, debugLines };
          spavCache[seats] = cached; // or spavCache.set(seats, cached)
        }

        // 4) Use the cached results
        const { results, debugLines } = cached;

        // Now update chart data
        spavChart.data.labels = results.map(a => a.text);
        spavChart.data.datasets[0].data = results.map(a => a.seatCount);
        spavChart.update();

        // Update winners list
        const winners = results.filter(a => a.seatCount > 0);
        let html = '<h4>Winners</h4><ul>';
        winners.forEach((w) => {
          html += `<li>${w.text} (Seats: ${w.seatCount})</li>`;
        });
        html += '</ul>';
        winnersList.innerHTML = html;

        // Display debug log in the page
        allocationLogDiv.textContent = debugLines.join('\n');
      }

      // Listen to slider
      seatsSlider.addEventListener('input', updateAllocation)

      // Initial run
      updateAllocation()

      // (Optional) Build a table for debugging the raw ballots
      function buildVotesTable(ballots, allChoices) {
        let html = '<table class="table table-striped">'
        html += '<thead><tr><th>Ballot #</th><th>Approved IDs</th><th>Approved Text</th></tr></thead>'
        html += '<tbody>'

        ballots.forEach((approvedChoices, index) => {
          const approvedTexts = approvedChoices.map((cid) => {
            const c = allChoices.find((ch) => ch.id === cid)
            return c ? c.choice_text : `Unknown(${cid})`
          })
          html += `<tr>
            <td>${index + 1}</td>
            <td>${approvedChoices.join(', ')}</td>
            <td>${approvedTexts.join(', ')}</td>
          </tr>`
        })

        html += '</tbody></table>'
        votesTableDiv.innerHTML = html
      }
    })
</script>
{% endblock %}
